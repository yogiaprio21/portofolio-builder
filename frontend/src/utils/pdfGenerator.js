function normalizePdfOptions(input) {
  if (typeof input === 'string') return { filename: input };
  return input || {};
}

async function withPdfSafeClass(element, task) {
  if (!element) return task();
  element.classList.add('pdf-safe');
  try {
    return await task();
  } finally {
    element.classList.remove('pdf-safe');
  }
}

export async function downloadPdfFromElement(element, opts = {}) {
  const options = normalizePdfOptions(opts);
  const { filename = 'portfolio.pdf' } = options;

  return await withPdfSafeClass(element, async () => {
    // 1. Temporarily change the document title for the PDF filename
    // (most browsers use the <title> tag as the default PDF save name)
    const originalTitle = document.title;
    document.title = filename.replace('.pdf', '');

    // 2. Add a special 'printing' class to the body.
    // We will use CSS in index.css to hide everything EXCEPT the .print-target
    document.body.classList.add('is-printing-cv');
    element.classList.add('print-target');

    try {
      // Give the browser a tiny moment to apply classes before opening dialog
      await new Promise((r) => setTimeout(r, 100));
      // 3. Trigger native browser print dialog
      // This allows the user to 'Save as PDF' with real selectable text!
      window.print();
    } finally {
      // 4. Restore everything
      document.title = originalTitle;
      document.body.classList.remove('is-printing-cv');
      element.classList.remove('print-target');
    }
  });
}

export async function generateA4PdfFromElement(element, opts = {}) {
  const [{ default: jsPDF }, htmlToImage] = await Promise.all([
    import('jspdf'),
    import('html-to-image'),
  ]);
  const {
    filename = 'portfolios.pdf',
    header = '',
    footer = '',
    marginMm = 20,
    pixelRatio = 2,
    quality = 0.85,
    useCORS = true,
    backgroundColor = '#ffffff',
  } = opts;
  const toCanvas = htmlToImage.toCanvas;
  const canvas = await withPdfSafeClass(element, () =>
    toCanvas(element, { pixelRatio, cacheBust: true, useCORS, backgroundColor }),
  );
  const imgWidthPx = canvas.width;
  const imgHeightPx = canvas.height;
  const pdf = new jsPDF('p', 'mm', 'a4');
  const pageW = pdf.internal.pageSize.getWidth();
  const pageH = pdf.internal.pageSize.getHeight();
  const contentW = Math.max(10, pageW - marginMm * 2);
  const contentH = Math.max(10, pageH - marginMm * 2);
  const totalHeightMm = contentW * (imgHeightPx / imgWidthPx);
  const pages = Math.max(1, Math.ceil(totalHeightMm / contentH));
  const sliceHeightPx = Math.ceil(imgHeightPx / pages);
  for (let i = 0; i < pages; i++) {
    if (i > 0) pdf.addPage();
    const sliceCanvas = document.createElement('canvas');
    sliceCanvas.width = imgWidthPx;
    sliceCanvas.height = Math.min(sliceHeightPx, imgHeightPx - i * sliceHeightPx);
    const ctx = sliceCanvas.getContext('2d');
    ctx.drawImage(
      canvas,
      0,
      i * sliceHeightPx,
      imgWidthPx,
      sliceCanvas.height,
      0,
      0,
      imgWidthPx,
      sliceCanvas.height,
    );
    const dataUrl = sliceCanvas.toDataURL('image/jpeg', quality);
    const sliceHeightMm = contentW * (sliceCanvas.height / imgWidthPx);
    pdf.addImage(dataUrl, 'JPEG', marginMm, marginMm, contentW, sliceHeightMm);
    pdf.setFontSize(10);
    if (header) {
      pdf.text(header, marginMm, marginMm - 8 < 8 ? 12 : marginMm - 8);
    }
    const pageLabel = `Halaman ${i + 1} dari ${pages}`;
    if (footer) {
      pdf.text(footer, marginMm, pageH - 10);
      pdf.text(pageLabel, pageW - marginMm, pageH - 10, { align: 'right' });
    } else {
      pdf.text(pageLabel, pageW - marginMm, pageH - 10, { align: 'right' });
    }
  }
  pdf.save(filename);
}

export async function generateA4PdfFromCards(cardElements, opts = {}) {
  const [{ default: jsPDF }, htmlToImage] = await Promise.all([
    import('jspdf'),
    import('html-to-image'),
  ]);
  const {
    filename = 'portfolios.pdf',
    header = 'Portfolios',
    footer = 'Generated by Portfolio Builder',
    marginMm = 20,
    pixelRatio = 2,
    gapMm = 6,
    quality = 0.85,
    useCORS = true,
    backgroundColor = '#ffffff',
  } = opts;
  const toCanvas = htmlToImage.toCanvas;
  const pdf = new jsPDF('p', 'mm', 'a4');
  const pageW = pdf.internal.pageSize.getWidth();
  const pageH = pdf.internal.pageSize.getHeight();
  const contentW = Math.max(10, pageW - marginMm * 2);
  const contentH = Math.max(10, pageH - marginMm * 2);
  let currentY = 0;
  let pageIndex = 0;
  const ensurePage = () => {
    if (pageIndex > 0) pdf.addPage();
    pageIndex += 1;
    pdf.setFontSize(11);
    if (header) pdf.text(header, marginMm, marginMm - 8);
    const pageLabel = `Halaman ${pageIndex}`;
    if (footer) {
      pdf.text(footer, marginMm, pageH - marginMm / 2);
      pdf.text(pageLabel, pageW - marginMm, pageH - marginMm / 2, { align: 'right' });
    } else {
      pdf.text(pageLabel, pageW - marginMm, pageH - marginMm / 2, { align: 'right' });
    }
    currentY = 0;
  };
  ensurePage();
  for (const el of cardElements) {
    const canvas = await withPdfSafeClass(el, () =>
      toCanvas(el, { pixelRatio, cacheBust: true, useCORS, backgroundColor }),
    );
    const imgWidthPx = canvas.width;
    const imgHeightPx = canvas.height;
    const sliceHeightMm = contentW * (imgHeightPx / imgWidthPx);
    if (currentY + sliceHeightMm > contentH) {
      ensurePage();
    }
    const dataUrl = canvas.toDataURL('image/jpeg', quality);
    pdf.addImage(dataUrl, 'JPEG', marginMm, marginMm + currentY, contentW, sliceHeightMm);
    currentY += sliceHeightMm + gapMm;
  }
  pdf.save(filename);
}
